---
title: "Power Comparisons with Kernels and Bandwidth Selection"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=F, warning=F}
library(rmutil)
library(extraDistr)
library(ggplot2)
```


## Kernel Density Estimation
The choices of kernel functions include Gaussian, Epanechnikov, Biweight, Box, Triangular.
```{r}
f_hat.function <- function(x, sample, h, kernel = "gaussian") {
  n <- length(sample)
  k <- 0
  if (kernel == "gaussian" || kernel == "normal") {
    k = dnorm((x-sample)/h)
  } else {
    indicator <- (abs((x-sample)/h) <= 1)
    if (kernel == "biweight" || kernel == "quartic") {
      k = (15/16 * (1-(((x-sample)/h))^2)^2)*indicator
    } else if (kernel == "box" || kernel == "uniform") {
      k = dunif((x-sample)/h) * indicator
    } else if (kernel == "triangular") {
      k = (1 - abs((x-sample)/h)) * indicator
    } else if (kernel == "Epanechnikov") {
      k = (3/4 * (1- ((x-sample)/h)^2)) * indicator
    } else if (kernel == "tricube") {
      k = (70/81 * (1 - abs((x-sample)/h)^3)^3) * indicator
    }
  }
  f <- sum(k)
  f <- f / (n * h)
  return (f)
}
```


## Monte Carlo Statistic
```{r}
# Compute the statistic for Monte Carlo procedure
monte.carlo.statistic <- function(x, h, kernel = "gaussian") {
  n <- length(x)
  monte.mean <- mean(x, trim = 0.1) # trimmed mean
  monte.sd <- sd.robust.estimate(x) # sd for this normal sample
  z <- (x-monte.mean)/monte.sd
  monte.h_ns <- 1.06 * 1 * (n ^ (-1/5)) # bandwidth for this normal sample
  
  log_monte_f <- rep(0,n)
  for (i in 1:n) {
    log_monte_f[i] <- log(f_hat.function(z[i], z, h, kernel))
  }
  e_monte <- log_monte_f - log(dnorm(z, mean = 0, sd = 1))
  
  s_monte <- sum(e_monte^2) #sum of squared error
  return(s_monte)
}

# Compute the robust estimate of the standard deviation
# mean standard deviation (multiplied by 1.4826)
sd.robust.estimate <- function(x) {
  return(sum(abs(x-mean(x)))/n * 1.4826)
}
```


## Power Computation
This function computes the power given a matrix of test sample.  
```{r}
compute.power <- function(test.sample, M, n, N, alpha = 0.05, h, kernel = "gaussian") {
  # monte carlo simulation
  s_monte <- rep(0,N)
  for (j in 1:N) {
    ## simulated normal sample with robust sd estimate
    monte.normal.sample <- rnorm(n, mean = 0, sd = 1)
    #Vector of sum of squared error for all instances of monte carlo simulations
    s_monte[j] <- monte.carlo.statistic(monte.normal.sample, h, kernel) 
  }
  
  power <- 0
  
  for (m in 1:M) {
    dat <- test.sample[m,]
      
    # observed statistic
    s_obs <- monte.carlo.statistic(dat, h, kernel)
  
    # monte carlo pvalue - equals to the sum of squared errors for 
    # monte carlo simulations greater or equal to the observed one
    pvalue <- sum(s_monte >= s_obs) / N 
  
    power <- power + (pvalue < alpha) * 1 / M
  }
  return(power)
}
```


## Power Comparison

### Parameter Setting
\begin{itemize} 
\item $M = \text{number of test samples to compute a power}$
\item $n = \text{sample size of each test sample}$
\item $N = \text{number of independent normal sample to simulate a TS band}$ 
\item $\alpha = \text{type I error}$
\item $\text{test.sample}=\text{matrix of test sample, must be an } M\times n \text{ matrix}$
\end{itemize}
```{r, eval=F}
M = 1000
n = 100
N = 10000
alpha = 0.05
```


```{r, eval=F}
test.sample <- matrix(nrow = M, ncol = n)
for (m in 1:M) {
  test.sample[m,] <- rpois(n, 15)
}
```


### Simulation
```{r, eval=F}
bandwidths <- c(seq(0.05, 1, by = 0.05), 2, 3, 4, 5)

kernels <- c("gaussian", "biweight", "box", "triangular", "Epanechnikov", "tricube")

powers <- matrix(nrow = length(bandwidths), ncol = length(kernels))

for (j in 1:length(kernels)) {
  cat(kernels[j], "\n")
  for (i in 1:length(bandwidths)) {
    powers[i,j] <- compute.power(test.sample, M, n, N, alpha, 
                                  h = bandwidths[i], kernel = kernels[j])
    cat(bandwidths[i], "\n")
  }
}
``` 

```{r, eval=F}
powers <- cbind(bandwidths, powers)
colnames(powers) <- c("bandwidth", kernels)
powers <- data.frame(powers)
powers
```

Change the name of the file for each distribution
```{r, eval=F}
write.csv(powers, "poisson(15).csv", row.names = F)
```



## Results
### Uniform(1,18)
```{r}
powers <- read.csv("uniform(1,18).csv")
```

```{r}
h.normal <- 1.06 * 1 * (n ^ (-1/5)) # normal scale bandwidth

ggplot(powers[1:20,], aes(x = bandwidth)) +
  geom_point(aes(y=gaussian, color = "Gaussian")) +
  geom_point(aes(y=biweight, color = "biweight")) +
  geom_point(aes(y=box, color = "box")) +
  geom_point(aes(y=triangular, color = "triangular")) +
  geom_point(aes(y=Epanechnikov, color = "Epanechnikov")) +
  geom_point(aes(y=tricube, color = "tricube")) +
  geom_line(aes(y=gaussian, color = "Gaussian")) +
  geom_line(aes(y=biweight, color = "biweight")) +
  geom_line(aes(y=box, color = "box")) +
  geom_line(aes(y=triangular, color = "triangular")) +
  geom_line(aes(y=Epanechnikov, color = "Epanechnikov")) +
  geom_line(aes(y=tricube, color = "tricube")) +
  geom_vline(aes(xintercept = h.normal)) +
  ylab("power") + 
  labs(color = "kernel functions") +
  ggtitle("Powers for Uniform(1,18)")
```

### Poisson(15)
```{r}
powers <- read.csv("poisson(15).csv")
```

```{r}
h.normal <- 1.06 * 1 * (n ^ (-1/5)) # normal scale bandwidth

ggplot(powers[1:20,], aes(x = bandwidth)) +
  geom_point(aes(y=gaussian, color = "Gaussian")) +
  geom_point(aes(y=biweight, color = "biweight")) +
  geom_point(aes(y=box, color = "box")) +
  geom_point(aes(y=triangular, color = "triangular")) +
  geom_point(aes(y=Epanechnikov, color = "Epanechnikov")) +
  geom_point(aes(y=tricube, color = "tricube")) +
  geom_line(aes(y=gaussian, color = "Gaussian")) +
  geom_line(aes(y=biweight, color = "biweight")) +
  geom_line(aes(y=box, color = "box")) +
  geom_line(aes(y=triangular, color = "triangular")) +
  geom_line(aes(y=Epanechnikov, color = "Epanechnikov")) +
  geom_line(aes(y=tricube, color = "tricube")) +
  geom_vline(aes(xintercept = h.normal)) +
  ylab("power") + 
  labs(color = "kernel functions") +
  ggtitle("Powers for Poisson(15)")
```
